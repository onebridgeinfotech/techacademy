{"ast":null,"code":"// Resume Parser Service\n// Note: In production, you would integrate with PDF parsing libraries\n// For now, we'll use mock data for demonstration\n\nclass ResumeParserService {\n  async parseResume(file) {\n    try {\n      // Mock resume parsing - in production, integrate with PDF parsing libraries\n      const mockText = `John Doe\nSoftware Developer\njohn.doe@email.com\n(555) 123-4567\nNew York, NY\n\nEXPERIENCE\nSoftware Developer at TechCorp (2020-2023)\n- Developed web applications using React and Node.js\n- Implemented RESTful APIs and database design\n- Collaborated with cross-functional teams\n\nEDUCATION\nBachelor of Computer Science\nUniversity of Technology (2016-2020)\n\nSKILLS\nJavaScript, React, Node.js, Python, SQL, AWS, Git\n\nPROJECTS\nE-commerce Website - Built using React and Node.js\nTask Management App - Full-stack application with MongoDB\nData Analysis Tool - Python-based data visualization`;\n      const parsedData = this.extractStructuredData(mockText);\n      return {\n        text: mockText,\n        ...parsedData\n      };\n    } catch (error) {\n      console.error('Error parsing resume:', error);\n      throw new Error('Failed to parse resume');\n    }\n  }\n\n  // Mock parsing methods - in production, integrate with PDF parsing libraries\n  async parsePDF(file) {\n    return 'Mock PDF content';\n  }\n  async parseWord(file) {\n    return 'Mock Word document content';\n  }\n  async parseText(file) {\n    return 'Mock text file content';\n  }\n  extractStructuredData(text) {\n    const lines = text.split('\\n').map(line => line.trim()).filter(line => line.length > 0);\n    return {\n      skills: this.extractSkills(text),\n      experience: this.extractExperience(text),\n      education: this.extractEducation(text),\n      projects: this.extractProjects(text),\n      certifications: this.extractCertifications(text),\n      achievements: this.extractAchievements(text),\n      contact: this.extractContact(text)\n    };\n  }\n  extractSkills(text) {\n    const skillKeywords = ['JavaScript', 'Python', 'Java', 'C++', 'C#', 'React', 'Angular', 'Vue', 'Node.js', 'Express', 'Django', 'Flask', 'Spring', 'ASP.NET', 'HTML', 'CSS', 'Bootstrap', 'Tailwind', 'SASS', 'LESS', 'SQL', 'MySQL', 'PostgreSQL', 'MongoDB', 'Redis', 'AWS', 'Azure', 'GCP', 'Docker', 'Kubernetes', 'Jenkins', 'Git', 'GitHub', 'GitLab', 'JIRA', 'Confluence', 'Agile', 'Scrum', 'DevOps', 'CI/CD', 'Microservices'];\n    const foundSkills = [];\n    const lowerText = text.toLowerCase();\n    skillKeywords.forEach(skill => {\n      if (lowerText.includes(skill.toLowerCase())) {\n        foundSkills.push(skill);\n      }\n    });\n    return Array.from(new Set(foundSkills));\n  }\n  extractExperience(text) {\n    const experienceRegex = /(?:experience|work history|employment|professional experience)/i;\n    const lines = text.split('\\n');\n    const experience = [];\n    let inExperienceSection = false;\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      if (experienceRegex.test(line)) {\n        inExperienceSection = true;\n        continue;\n      }\n      if (inExperienceSection) {\n        if (line.match(/^\\d{4}/) || line.match(/^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i)) {\n          experience.push(line);\n        } else if (line.length > 10 && !line.match(/^(education|skills|certifications|projects)/i)) {\n          experience.push(line);\n        }\n      }\n    }\n    return experience;\n  }\n  extractEducation(text) {\n    const educationRegex = /(?:education|academic|qualification|degree)/i;\n    const lines = text.split('\\n');\n    const education = [];\n    let inEducationSection = false;\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      if (educationRegex.test(line)) {\n        inEducationSection = true;\n        continue;\n      }\n      if (inEducationSection) {\n        if (line.match(/bachelor|master|phd|diploma|certificate|degree/i)) {\n          education.push(line);\n        }\n      }\n    }\n    return education;\n  }\n  extractProjects(text) {\n    const projectRegex = /(?:projects|portfolio|work samples)/i;\n    const lines = text.split('\\n');\n    const projects = [];\n    let inProjectSection = false;\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      if (projectRegex.test(line)) {\n        inProjectSection = true;\n        continue;\n      }\n      if (inProjectSection) {\n        if (line.length > 10 && !line.match(/^(skills|experience|education|certifications)/i)) {\n          projects.push(line);\n        }\n      }\n    }\n    return projects;\n  }\n  extractCertifications(text) {\n    const certRegex = /(?:certifications|certificates|licenses)/i;\n    const lines = text.split('\\n');\n    const certifications = [];\n    let inCertSection = false;\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      if (certRegex.test(line)) {\n        inCertSection = true;\n        continue;\n      }\n      if (inCertSection) {\n        if (line.match(/certified|certificate|license|aws|azure|google|microsoft/i)) {\n          certifications.push(line);\n        }\n      }\n    }\n    return certifications;\n  }\n  extractAchievements(text) {\n    const achievementRegex = /(?:achievements|awards|honors|recognition)/i;\n    const lines = text.split('\\n');\n    const achievements = [];\n    let inAchievementSection = false;\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      if (achievementRegex.test(line)) {\n        inAchievementSection = true;\n        continue;\n      }\n      if (inAchievementSection) {\n        if (line.length > 10 && !line.match(/^(skills|experience|education|certifications|projects)/i)) {\n          achievements.push(line);\n        }\n      }\n    }\n    return achievements;\n  }\n  extractContact(text) {\n    const contact = {};\n\n    // Extract email\n    const emailRegex = /([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})/;\n    const emailMatch = text.match(emailRegex);\n    if (emailMatch) {\n      contact.email = emailMatch[1];\n    }\n\n    // Extract phone\n    const phoneRegex = /(\\+?[\\d\\s\\-\\(\\)]{10,})/;\n    const phoneMatch = text.match(phoneRegex);\n    if (phoneMatch) {\n      contact.phone = phoneMatch[1];\n    }\n\n    // Extract name (usually at the beginning)\n    const lines = text.split('\\n').slice(0, 5);\n    for (const line of lines) {\n      if (line.length > 2 && line.length < 50 && !line.match(/@|phone|email|address/i)) {\n        contact.name = line;\n        break;\n      }\n    }\n    return contact;\n  }\n}\nexport const resumeParserService = new ResumeParserService();","map":{"version":3,"names":["ResumeParserService","parseResume","file","mockText","parsedData","extractStructuredData","text","error","console","Error","parsePDF","parseWord","parseText","lines","split","map","line","trim","filter","length","skills","extractSkills","experience","extractExperience","education","extractEducation","projects","extractProjects","certifications","extractCertifications","achievements","extractAchievements","contact","extractContact","skillKeywords","foundSkills","lowerText","toLowerCase","forEach","skill","includes","push","Array","from","Set","experienceRegex","inExperienceSection","i","test","match","educationRegex","inEducationSection","projectRegex","inProjectSection","certRegex","inCertSection","achievementRegex","inAchievementSection","emailRegex","emailMatch","email","phoneRegex","phoneMatch","phone","slice","name","resumeParserService"],"sources":["C:/Users/UdayaCharagundla/OneDrive - kyndryl/Desktop/golive/golive-cursor/techacademy/src/services/resumeParser.ts"],"sourcesContent":["// Resume Parser Service\n// Note: In production, you would integrate with PDF parsing libraries\n// For now, we'll use mock data for demonstration\n\nexport interface ParsedResume {\n  text: string;\n  skills: string[];\n  experience: string[];\n  education: string[];\n  projects: string[];\n  certifications: string[];\n  achievements: string[];\n  contact: {\n    name?: string;\n    email?: string;\n    phone?: string;\n    location?: string;\n  };\n}\n\nclass ResumeParserService {\n  async parseResume(file: File): Promise<ParsedResume> {\n    try {\n      // Mock resume parsing - in production, integrate with PDF parsing libraries\n      const mockText = `John Doe\nSoftware Developer\njohn.doe@email.com\n(555) 123-4567\nNew York, NY\n\nEXPERIENCE\nSoftware Developer at TechCorp (2020-2023)\n- Developed web applications using React and Node.js\n- Implemented RESTful APIs and database design\n- Collaborated with cross-functional teams\n\nEDUCATION\nBachelor of Computer Science\nUniversity of Technology (2016-2020)\n\nSKILLS\nJavaScript, React, Node.js, Python, SQL, AWS, Git\n\nPROJECTS\nE-commerce Website - Built using React and Node.js\nTask Management App - Full-stack application with MongoDB\nData Analysis Tool - Python-based data visualization`;\n\n      const parsedData = this.extractStructuredData(mockText);\n      \n      return {\n        text: mockText,\n        ...parsedData\n      };\n    } catch (error) {\n      console.error('Error parsing resume:', error);\n      throw new Error('Failed to parse resume');\n    }\n  }\n\n  // Mock parsing methods - in production, integrate with PDF parsing libraries\n  private async parsePDF(file: File): Promise<string> {\n    return 'Mock PDF content';\n  }\n\n  private async parseWord(file: File): Promise<string> {\n    return 'Mock Word document content';\n  }\n\n  private async parseText(file: File): Promise<string> {\n    return 'Mock text file content';\n  }\n\n  private extractStructuredData(text: string): Omit<ParsedResume, 'text'> {\n    const lines = text.split('\\n').map(line => line.trim()).filter(line => line.length > 0);\n    \n    return {\n      skills: this.extractSkills(text),\n      experience: this.extractExperience(text),\n      education: this.extractEducation(text),\n      projects: this.extractProjects(text),\n      certifications: this.extractCertifications(text),\n      achievements: this.extractAchievements(text),\n      contact: this.extractContact(text)\n    };\n  }\n\n  private extractSkills(text: string): string[] {\n    const skillKeywords = [\n      'JavaScript', 'Python', 'Java', 'C++', 'C#', 'React', 'Angular', 'Vue',\n      'Node.js', 'Express', 'Django', 'Flask', 'Spring', 'ASP.NET',\n      'HTML', 'CSS', 'Bootstrap', 'Tailwind', 'SASS', 'LESS',\n      'SQL', 'MySQL', 'PostgreSQL', 'MongoDB', 'Redis',\n      'AWS', 'Azure', 'GCP', 'Docker', 'Kubernetes', 'Jenkins',\n      'Git', 'GitHub', 'GitLab', 'JIRA', 'Confluence',\n      'Agile', 'Scrum', 'DevOps', 'CI/CD', 'Microservices'\n    ];\n\n    const foundSkills: string[] = [];\n    const lowerText = text.toLowerCase();\n\n    skillKeywords.forEach(skill => {\n      if (lowerText.includes(skill.toLowerCase())) {\n        foundSkills.push(skill);\n      }\n    });\n\n    return Array.from(new Set(foundSkills));\n  }\n\n  private extractExperience(text: string): string[] {\n    const experienceRegex = /(?:experience|work history|employment|professional experience)/i;\n    const lines = text.split('\\n');\n    const experience: string[] = [];\n    let inExperienceSection = false;\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      \n      if (experienceRegex.test(line)) {\n        inExperienceSection = true;\n        continue;\n      }\n      \n      if (inExperienceSection) {\n        if (line.match(/^\\d{4}/) || line.match(/^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i)) {\n          experience.push(line);\n        } else if (line.length > 10 && !line.match(/^(education|skills|certifications|projects)/i)) {\n          experience.push(line);\n        }\n      }\n    }\n\n    return experience;\n  }\n\n  private extractEducation(text: string): string[] {\n    const educationRegex = /(?:education|academic|qualification|degree)/i;\n    const lines = text.split('\\n');\n    const education: string[] = [];\n    let inEducationSection = false;\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      \n      if (educationRegex.test(line)) {\n        inEducationSection = true;\n        continue;\n      }\n      \n      if (inEducationSection) {\n        if (line.match(/bachelor|master|phd|diploma|certificate|degree/i)) {\n          education.push(line);\n        }\n      }\n    }\n\n    return education;\n  }\n\n  private extractProjects(text: string): string[] {\n    const projectRegex = /(?:projects|portfolio|work samples)/i;\n    const lines = text.split('\\n');\n    const projects: string[] = [];\n    let inProjectSection = false;\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      \n      if (projectRegex.test(line)) {\n        inProjectSection = true;\n        continue;\n      }\n      \n      if (inProjectSection) {\n        if (line.length > 10 && !line.match(/^(skills|experience|education|certifications)/i)) {\n          projects.push(line);\n        }\n      }\n    }\n\n    return projects;\n  }\n\n  private extractCertifications(text: string): string[] {\n    const certRegex = /(?:certifications|certificates|licenses)/i;\n    const lines = text.split('\\n');\n    const certifications: string[] = [];\n    let inCertSection = false;\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      \n      if (certRegex.test(line)) {\n        inCertSection = true;\n        continue;\n      }\n      \n      if (inCertSection) {\n        if (line.match(/certified|certificate|license|aws|azure|google|microsoft/i)) {\n          certifications.push(line);\n        }\n      }\n    }\n\n    return certifications;\n  }\n\n  private extractAchievements(text: string): string[] {\n    const achievementRegex = /(?:achievements|awards|honors|recognition)/i;\n    const lines = text.split('\\n');\n    const achievements: string[] = [];\n    let inAchievementSection = false;\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      \n      if (achievementRegex.test(line)) {\n        inAchievementSection = true;\n        continue;\n      }\n      \n      if (inAchievementSection) {\n        if (line.length > 10 && !line.match(/^(skills|experience|education|certifications|projects)/i)) {\n          achievements.push(line);\n        }\n      }\n    }\n\n    return achievements;\n  }\n\n  private extractContact(text: string): ParsedResume['contact'] {\n    const contact: ParsedResume['contact'] = {};\n    \n    // Extract email\n    const emailRegex = /([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})/;\n    const emailMatch = text.match(emailRegex);\n    if (emailMatch) {\n      contact.email = emailMatch[1];\n    }\n    \n    // Extract phone\n    const phoneRegex = /(\\+?[\\d\\s\\-\\(\\)]{10,})/;\n    const phoneMatch = text.match(phoneRegex);\n    if (phoneMatch) {\n      contact.phone = phoneMatch[1];\n    }\n    \n    // Extract name (usually at the beginning)\n    const lines = text.split('\\n').slice(0, 5);\n    for (const line of lines) {\n      if (line.length > 2 && line.length < 50 && !line.match(/@|phone|email|address/i)) {\n        contact.name = line;\n        break;\n      }\n    }\n    \n    return contact;\n  }\n}\n\nexport const resumeParserService = new ResumeParserService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}